// Generated by CoffeeScript 1.6.2
(function() {
  var DEFAULT_PORT, Markup, Server, express, fs, isRegExp, isString, jade, path, util,
    __hasProp = {}.hasOwnProperty;

  express = require('express');

  path = require('path');

  util = require('util');

  fs = require('fs');

  jade = require('jade');

  module.exports.DEFAULT_PORT = DEFAULT_PORT = 7777;

  isString = function(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
  };

  isRegExp = function(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };

  Server = (function() {
    function Server(markup) {
      var app;

      this.app = app = express();
      if (isString(markup)) {
        markup = new Markup(markup);
      }
      app.set('views', __dirname + '/views');
      app.set('view engine', 'jade');
      app.use(express.bodyParser());
      app.use('/static', express["static"](__dirname + '/static'));
      app.configure('development', function() {
        app.use(express.errorHandler({
          dumpException: true,
          showStack: true
        }));
        return app.set('view options', {
          pretty: true
        });
      });
      app.configure('production', function() {
        return app.use(express.errorHandler());
      });
      app.get('/', function(req, res) {
        return markup.timestamp(function(err, ts) {
          if (err) {
            console.error(err);
            throw err;
          }
          return markup.html(function(err, html) {
            if (err) {
              console.error(err);
              throw err;
            }
            return res.render('index', {
              title: markup.title,
              timestamp: ts,
              html: html
            });
          });
        });
      });
      app.del('/', function() {
        return app.close();
      });
      app.post('/update', function(req, res) {
        var timestamp;

        timestamp = req.body.timestamp;
        if (timestamp == null) {
          res.send(400, 'malformed JSON');
        }
        return markup.timestamp(function(err, ts) {
          var ret;

          if (err) {
            console.error(err);
            throw err;
          }
          ret = {
            title: markup.title,
            timestamp: ts,
            html: null
          };
          if (ts === timestamp) {
            return res.json(ret);
          } else {
            console.log('detected file change');
            return markup.html(function(err, html) {
              if (err) {
                console.error(err);
                throw err;
              }
              ret.html = html;
              return res.json(ret);
            });
          }
        });
      });
    }

    Server.prototype.listen = function(port) {
      if (port == null) {
        port = DEFAULT_PORT;
      }
      console.log("Server listening at " + port);
      return this.app.listen(port);
    };

    Server.prototype.close = function() {
      return this.app.close();
    };

    return Server;

  })();

  module.exports.Server = Server;

  Markup = (function() {
    function Markup(filename) {
      if (!fs.existsSync(filename)) {
        throw new Error("input file '" + filename + "' doesn't exist");
      }
      this.filename = filename = path.resolve(process.cwd(), filename);
      this.title = "" + (path.basename(filename)) + " - " + (path.dirname(filename));
    }

    Markup.prototype.timestamp = function(callback) {
      return fs.stat(this.filename, function(err, stat) {
        if (err) {
          callback(err, null);
        }
        return callback(null, stat.mtime.getTime());
      });
    };

    Markup.prototype.html = function(callback) {
      var detect, found, name, options, _ref;

      found = false;
      _ref = Markup.ftdetects;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        detect = _ref[name];
        if ((isRegExp(detect) && detect.test(this.filename)) || detect(this.filename)) {
          options = Markup.rendererOptions[name];
          Markup.renderers[name](this.filename, options, callback);
          found = true;
        }
      }
      if (!found) {
        return callback(new Error('renderer not found'), null);
      }
    };

    Markup.prototype["export"] = function() {
      var render;

      if (this.exportTemplate == null) {
        this.exportTemplate = fs.readFileSync(__dirname + '/views/export.jade');
      }
      render = jade.compile(this.exportTemplate);
      return render({
        html: this.html()
      });
    };

    return Markup;

  })();

  Markup.ftdetects = {
    'markdown': /\.(markdown|md|mdown|mkd|mkdn)$/
  };

  Markup.renderers = {
    'markdown': require('./markdown').render
  };

  Markup.rendererOptions = {};

  module.exports.Markup = Markup;

}).call(this);
